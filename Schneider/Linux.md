#### Linux

#####1. expr  let  eval

   expr命令是一个手工命令行计数器，用空格隔开每个项；

#####2. 间接引用变量

   eval echo \$$varname

   echo ${!varname}

#####3. 调用脚本的函数

   source ***.sh

   functionName

#####4. exec单步调试


   exec内建命令并不启动新的shell，而是用被执行的命令替换当前的shell进程，并将老进程的环境清理掉，在exec之后的其他命令也不再执行。

#####5. case语句

   双引号结束

#####6. $( ) 与  (反引号)

   $(( )) 的整数运算

#####7. awk 编程语言

   awk的处理文本和数据的方式是这样的，它逐行扫描文件，从第一行到最后一行，寻找匹配的特定模式的行，并在这些行上进行你想要的操作。如果没有指定处理动作，则把匹配的行显示到标准输出(屏幕)，如果没有指定模式，则所有被操作所指定的行都被处理。

   - awk [options] 'script' var=value file(s)

   - awk [options] -f scriptfile var=value file(s)
     - awk脚本script是由模式和操作组成的：pattern {action} 

   - 格式处理和获取数据

     ```
     buildNum=`curl -F "_api_key=be1290e71bb2fab7a9547cda2ee37d7b" -F "appKey=8d52314a63156de90abff8a1413e7b8a" https://www.pgyer.com/apiv2/app/view | tr ',' '\n' | awk -F : '/buildUpdateDescription/{print $2}'| sed 's/"//g' | head -1 | awk -F _ '{print $2}'`
     ```

   - NF, 字段数量

   - NR, 存储当前已经读取了多少行的计数

   - printf 语句格式化输出代替print

   - sort 对awk输出进行排序  （sort -t 分隔符 -k 分割域序号）

   - 特殊模式 BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置。

   - 打印最后一个输入行

     虽然在 END 动作中 NR 还保留着它的值，但 $0 没有。程序

     ```
         { last = $0 }
     END { print last }
     ```

   - 内置函数 length

   - **模式摘要**

     \1. BEGIN { 语句 }

     在读取任何输入前执行一次 语句

     \2. END { 语句 }

     读取所有输入之后执行一次 语句

     \3. 表达式 { 语句 }

     对于 表达式 为真（即，非零或非空）的行，执行 语句

     \4. /正则表达式/ { 语句 }

     如果输入行包含字符串与 正则表达式 相匹配，则执行 语句

     \5. 组合模式 { 语句 }

     一个 组合模式 通过与（&&），或（||），非（|），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句

     \6. 模式1，模式2 { 语句 }

     范围模式(range pattern)匹配从与 模式1 相匹配的行到与 模式2 相匹配的行（包含该行）之间的所有行，对于这些输入行，执行 语句 。

     BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。

##### 8. sed(stream edit)

```
sed [options] 'command' file(s)
sed [options] -f scriptfile file(s)
```

sed命令

```
a\ 在当前行下面插入文本。
i\ 在当前行上面插入文本。
c\ 把选定的行改为新的文本。
d 删除，删除选择的行。
D 删除模板块的第一行。
s 替换指定字符
h 拷贝模板块的内容到内存中的缓冲区。
H 追加模板块的内容到内存中的缓冲区。
g 获得内存缓冲区的内容，并替代当前模板块中的文本。
G 获得内存缓冲区的内容，并追加到当前模板块文本的后面。
l 列表不能打印字符的清单。
n 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
N 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
p 打印模板块的行。
P(大写) 打印模板块的第一行。
q 退出Sed。
b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
r file 从file中读行。
t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
T label 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
w file 写并追加模板块到file末尾。  
W file 写并追加模板块的第一行到file末尾。  
! 表示后面的命令对所有没有被选定的行发生作用。  
= 打印当前行号码。  
# 把注释扩展到下一个换行符以前。  
```

替换标记

```
g 表示行内全面替换。  
p 表示打印行。  
w 表示把行写入一个文件。  
x 表示互换模板块中的文本和缓冲区中的文本。  
y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）
\1 子串匹配标记
& 已匹配字符串标记
```

元字符集

```
^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。
$ 匹配行结束，如：/sed$/匹配所有以sed结尾的行。
. 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。
* 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。
[] 匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。  
[^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。
\(..\) 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。
& 保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。
\< 匹配单词的开始，如:/\<love/匹配包含以love开头的单词的行。
\> 匹配单词的结束，如/love\>/匹配包含以love结尾的单词的行。
x\{m\} 重复字符x，m次，如：/0\{5\}/匹配包含5个0的行。
x\{m,\} 重复字符x，至少m次，如：/0\{5,\}/匹配至少有5个0的行。
x\{m,n\} 重复字符x，至少m次，不多于n次，如：/0\{5,10\}/匹配5~10个0的行。
```

- -n s/\*/\*/p 仅打印修改行

- 删除空白行 sed '/^$/d' file

- 已匹配字符串标记&

  正则表达式 \w\+ 匹配每一个单词，使用 [&] 替换它，& 对应于之前所匹配到的单词：

  ```
  echo this is a test line | sed 's/\w\+/[&]/g'
  [this] [is] [a] [test] [line]
  ```

- 子串匹配标记\1

  ```
  echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/'
  this is 7 in a number
  ```

- 选定行的范围：,（逗号）